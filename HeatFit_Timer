library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;  -- Use numeric_std for unsigned and signed arithmetic

entity HeatFit_Timer is
    Port (
        clk         : in  STD_LOGIC;
        reset       : in  STD_LOGIC; -- Reset to save in memory
        heart_rate  : in  STD_LOGIC; -- 1 for active, 0 for idle
        duration    : out STD_LOGIC_VECTOR(15 downto 0); -- Current duration
        memory      : out STD_LOGIC_VECTOR(15 downto 0); -- Saved duration
        highest_time: out STD_LOGIC_VECTOR(15 downto 0); -- Highest time recorded
        latest_time : out STD_LOGIC_VECTOR(15 downto 0); -- Most recent time recorded
        avg_time    : out STD_LOGIC_VECTOR(15 downto 0); -- Average time across all sessions
        
        -- New Indicators
        active_state : out STD_LOGIC;  -- Active state indicator
        stop_state   : out STD_LOGIC;  -- Stop state indicator
        reset_state  : out STD_LOGIC;  -- Reset state indicator
        
        -- Hours, Minutes, and Seconds output
        hours        : out STD_LOGIC_VECTOR(7 downto 0);  -- Hours as 8-bit vector
        minutes      : out STD_LOGIC_VECTOR(7 downto 0);  -- Minutes as 8-bit vector
        seconds      : out STD_LOGIC_VECTOR(7 downto 0)   -- Seconds as 8-bit vector
    );
end HeatFit_Timer;

architecture Behavioral of HeatFit_Timer is
    -- Internal signals and registers
    signal state             : STD_LOGIC := '0'; -- 0: Idle, 1: Counting
    signal counter           : unsigned(15 downto 0) := (others => '0');
    signal memory_reg        : unsigned(15 downto 0) := (others => '0');
    signal highest_time_reg  : unsigned(15 downto 0) := (others => '0');
    signal latest_time_reg   : unsigned(15 downto 0) := (others => '0');
    
    -- Signals for average time calculation
    signal total_time_reg    : unsigned(31 downto 0) := (others => '0');
    signal session_count_reg : unsigned(15 downto 0) := (others => '0');
    signal avg_time_reg      : unsigned(15 downto 0) := (others => '0');

    signal reset_prev        : STD_LOGIC := '0';
    signal reset_edge        : STD_LOGIC := '0';  -- Detects rising edge of reset
    signal reset_processing  : STD_LOGIC := '0';
    signal first_session_done : STD_LOGIC := '0';  -- Flag for the first session

    -- Indicators for states
    signal active_state_reg  : STD_LOGIC := '0';  -- Indicator for active state
    signal stop_state_reg    : STD_LOGIC := '0';  -- Indicator for stop state
    signal reset_state_reg   : STD_LOGIC := '0';  -- Indicator for reset state

    -- Signals for hours, minutes, and seconds
    signal hours_reg         : unsigned(7 downto 0) := (others => '0');
    signal minutes_reg       : unsigned(7 downto 0) := (others => '0');
    signal seconds_reg       : unsigned(7 downto 0) := (others => '0');

begin

    -- Rising edge detection for the reset signal
    process(clk)
    begin
        if rising_edge(clk) then
            reset_edge <= reset and not reset_prev;
            reset_prev <= reset;
        end if;
    end process;

    -- Main logic for HeatFit Timer
    process(clk)
    begin
        if rising_edge(clk) then
            -- If reset is asserted, handle reset and update the reset state indicator
            if reset = '1' then
                -- Save the current session data when reset is asserted
                if reset_processing = '0' then
                    -- Save current session duration in memory
                    memory_reg <= counter;

                    -- Update the highest time if necessary
                    if counter > highest_time_reg then
                        highest_time_reg <= counter;
                    end if;

                    -- Calculate the average time after the first session
                    if first_session_done = '0' then
                        -- If it's the first session, set the avg_time to the first session's duration
                        avg_time_reg <= counter;
                        first_session_done <= '1';  -- Mark that the first session is done
                    else
                        -- After the first session, calculate the average based on previous and current sessions
                        total_time_reg <= total_time_reg + resize(counter, 32);
                        session_count_reg <= session_count_reg + 1;

                        -- Calculate the average time (total time divided by number of sessions)
                        if session_count_reg > 0 then
                            avg_time_reg <= resize(total_time_reg / session_count_reg, 16);
                        end if;
                    end if;

                    -- Reset the counter immediately when reset is asserted
                    counter <= (others => '0');
                    -- Mark that reset is being processed
                    reset_processing <= '1';
                end if;
                reset_state_reg <= '1';  -- Set reset state indicator to 1
                active_state_reg <= '0'; -- Reset active state
                stop_state_reg <= '0';   -- Reset stop state
            else
                reset_state_reg <= '0';  -- Reset reset state indicator after reset is deasserted
                -- When reset is deasserted, update the latest time
                if reset_processing = '1' then
                    latest_time_reg <= counter - 2;
                    reset_processing <= '0';
                end if;
            end if;

            -- Logic to determine active and stop states
            if reset = '0' and heart_rate = '1' then
                state <= '1'; -- Active state
                active_state_reg <= '1';  -- Set active state
                stop_state_reg <= '0';    -- Clear stop state
            elsif reset = '0' and heart_rate = '0' then
                state <= '0'; -- Stop state
                active_state_reg <= '0';  -- Clear active state
                stop_state_reg <= '1';    -- Set stop state
            else
                if heart_rate = '1' then
                    if state = '0' then
                        state <= '1'; -- Start counting when heart rate is 1
                        active_state_reg <= '1';  -- Set active state indicator to 1
                        stop_state_reg <= '0';    -- Reset stop state
                    end if;
                else
                    if state = '1' then
                        state <= '0'; -- Stop counting when heart rate is 0
                        stop_state_reg <= '1';   -- Set stop state indicator to 1
                        active_state_reg <= '0'; -- Reset active state
                    end if;
                end if;
            end if;

            -- Update counter while counting
            if state = '1' then
                counter <= counter + 1;
                
            end if;

            -- Update hours, minutes, and seconds based on the counter
            -- Convert counter to hours, minutes, and seconds
            seconds_reg <= resize(counter mod 60, 8);
            minutes_reg <= resize((counter / 60) mod 60, 8);
            hours_reg <= resize(counter / 3600, 8);

        end if;
    end process;

    -- Output the state indicators to external signals
    active_state <= active_state_reg;
    stop_state <= stop_state_reg;
    reset_state <= reset_state_reg;

    -- Output the values to external signals
    duration <= std_logic_vector(counter);
    memory <= std_logic_vector(memory_reg);
    highest_time <= std_logic_vector(highest_time_reg);
    latest_time <= std_logic_vector(latest_time_reg);
    avg_time <= std_logic_vector(avg_time_reg);

    -- Output the hours, minutes, and seconds to external signals
    hours <= std_logic_vector(hours_reg);
    minutes <= std_logic_vector(minutes_reg);
    seconds <= std_logic_vector(seconds_reg);

end Behavioral;
