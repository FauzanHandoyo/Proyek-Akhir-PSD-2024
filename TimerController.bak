library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity TimerController is
    Port (
        clk           : in STD_LOGIC;
        reset         : in STD_LOGIC;
        count         : in STD_LOGIC_VECTOR(15 downto 0);  -- 16-bit input
        memory        : out STD_LOGIC_VECTOR(15 downto 0);  -- 16-bit output
        highest_time  : out STD_LOGIC_VECTOR(15 downto 0);  -- 16-bit output
        latest_time   : out STD_LOGIC_VECTOR(15 downto 0);  -- 16-bit output
        avg_time      : out STD_LOGIC_VECTOR(15 downto 0);  -- 16-bit output
        hours         : out STD_LOGIC_VECTOR(7 downto 0);   -- 8-bit output for hours
        minutes       : out STD_LOGIC_VECTOR(7 downto 0);   -- 8-bit output for minutes
        seconds       : out STD_LOGIC_VECTOR(7 downto 0)    -- 8-bit output for seconds
    );
end TimerController;

architecture Behavioral of TimerController is
    -- Internal signals
    signal memory_reg       : unsigned(15 downto 0) := (others => '0');
    signal highest_time_reg : unsigned(15 downto 0) := (others => '0');
    signal latest_time_reg  : unsigned(15 downto 0) := (others => '0');
    signal total_time_reg   : unsigned(31 downto 0) := (others => '0');
    signal session_count_reg: unsigned(15 downto 0) := (others => '0');
    signal avg_time_reg     : unsigned(15 downto 0) := (others => '0');
    signal hours_reg        : unsigned(7 downto 0)  := (others => '0');
    signal minutes_reg      : unsigned(7 downto 0)  := (others => '0');
    signal seconds_reg      : unsigned(7 downto 0)  := (others => '0');
begin
    process(clk)
    begin
        if rising_edge(clk) then
            if reset = '1' then
                -- Reset all registers
                memory_reg       <= (others => '0');
                highest_time_reg <= (others => '0');
                latest_time_reg  <= (others => '0');
                total_time_reg   <= (others => '0');
                session_count_reg<= (others => '0');
                avg_time_reg     <= (others => '0');
                hours_reg        <= (others => '0');
                minutes_reg      <= (others => '0');
                seconds_reg      <= (others => '0');
            else
                -- Store current count as memory (only 16 bits of memory)
                memory_reg <= unsigned(count(15 downto 0)); -- Convert count from std_logic_vector to unsigned
                
                -- Update highest time (ensure it's within 16 bits)
                if unsigned(count(15 downto 0)) > highest_time_reg then
                    highest_time_reg <= unsigned(count(15 downto 0)); -- Convert to unsigned and assign
                end if;
                
                -- Update latest time (only 16 bits of latest time)
                latest_time_reg <= unsigned(count(15 downto 0)); -- Convert to unsigned

                -- Update total time and session count for average calculation (32-bit total time)
                total_time_reg <= total_time_reg + unsigned(count(15 downto 0)); -- Convert to unsigned for addition
                session_count_reg <= session_count_reg + 1;

                -- Calculate average time (only 16 bits output)
                if session_count_reg > 0 then
                    avg_time_reg <= total_time_reg / session_count_reg; -- Divide 32-bit by 16-bit unsigned values
                end if;

                -- Convert count to hours, minutes, and seconds (limit output to 8 bits for each)
                hours_reg <= unsigned(count(15 downto 0)) / 3600;  -- Use unsigned for division
                minutes_reg <= (unsigned(count(15 downto 0)) mod 3600) / 60;  -- Use unsigned for mod and division
                seconds_reg <= unsigned(count(15 downto 0)) mod 60;  -- Use unsigned for mod operation
            end if;
        end if;
    end process;

    -- Output signals (ensure correct length for each output)
    memory <= std_logic_vector(memory_reg);   -- Convert unsigned to std_logic_vector
    highest_time <= std_logic_vector(highest_time_reg);  -- Convert unsigned to std_logic_vector
    latest_time <= std_logic_vector(latest_time_reg);   -- Convert unsigned to std_logic_vector
    avg_time <= std_logic_vector(avg_time_reg);  -- Convert unsigned to std_logic_vector
    
    -- For hours, minutes, and seconds: Limit to 8 bits
    hours <= std_logic_vector(hours_reg(7 downto 0));   -- Only lower 8 bits for hours
    minutes <= std_logic_vector(minutes_reg(7 downto 0));  -- Only lower 8 bits for minutes
    seconds <= std_logic_vector(seconds_reg(7 downto 0));  -- Only lower 8 bits for seconds
end Behavioral;
