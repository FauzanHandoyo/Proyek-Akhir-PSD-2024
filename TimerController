library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity TimerController is
    Port (
        clk           : in STD_LOGIC;
        reset         : in STD_LOGIC;
        heart_rate    : in STD_LOGIC;  -- Start signal
        duration      : out STD_LOGIC_VECTOR(15 downto 0); -- Current count
        memory        : out STD_LOGIC_VECTOR(15 downto 0);
        highest_time  : out STD_LOGIC_VECTOR(15 downto 0);
        latest_time   : out STD_LOGIC_VECTOR(15 downto 0);
        avg_time      : out STD_LOGIC_VECTOR(15 downto 0);
        hours         : out STD_LOGIC_VECTOR(7 downto 0);
        minutes       : out STD_LOGIC_VECTOR(7 downto 0);
        seconds       : out STD_LOGIC_VECTOR(7 downto 0)
    );
end TimerController;

architecture Behavioral of TimerController is
    -- Internal signals
    signal counter_reg       : unsigned(15 downto 0) := (others => '0');
    signal memory_reg        : unsigned(15 downto 0) := (others => '0');
    signal highest_time_reg  : unsigned(15 downto 0) := (others => '0');
    signal latest_time_reg   : unsigned(15 downto 0) := (others => '0');
    signal total_time_reg    : unsigned(31 downto 0) := (others => '0');
    signal session_count_reg : unsigned(15 downto 0) := (others => '0');
    signal avg_time_reg      : unsigned(15 downto 0) := (others => '0');
    signal hours_reg         : unsigned(7 downto 0)  := (others => '0');
    signal minutes_reg       : unsigned(7 downto 0)  := (others => '0');
    signal seconds_reg       : unsigned(7 downto 0)  := (others => '0');
begin
    process(clk)
    begin
        if rising_edge(clk) then
            if reset = '1' then
                -- Reset all registers
                counter_reg       <= (others => '0');
                memory_reg        <= (others => '0');
                highest_time_reg  <= (others => '0');
                latest_time_reg   <= (others => '0');
                total_time_reg    <= (others => '0');
                session_count_reg <= (others => '0');
                avg_time_reg      <= (others => '0');
                hours_reg         <= (others => '0');
                minutes_reg       <= (others => '0');
                seconds_reg       <= (others => '0');
            else
                -- Counting logic integrated with heart rate
                if heart_rate = '1' then
                    counter_reg <= counter_reg + 1;
                end if;

                -- Memory update
                memory_reg <= counter_reg;

                -- Update highest time if new duration exceeds previous highest
                if reset = '1' and counter_reg > highest_time_reg then
                    highest_time_reg <= counter_reg;
                end if;

                -- Update latest time when reset is active
                if reset = '1' then
                    latest_time_reg <= counter_reg;
                end if;

                -- Update average time
                if reset = '1' then
                    total_time_reg <= total_time_reg + counter_reg;
                    session_count_reg <= session_count_reg + 1;
                    if session_count_reg > 0 then
                        avg_time_reg <= total_time_reg / session_count_reg;
                    end if;
                end if;

                -- Convert counter to hours, minutes, and seconds
                seconds_reg <= resize(counter_reg mod 60, 8);
                minutes_reg <= resize((counter_reg / 60) mod 60, 8);
                hours_reg   <= resize(counter_reg / 3600, 8);
            end if;
        end if;
    end process;

    -- Output assignments
    duration <= std_logic_vector(counter_reg);
    memory <= std_logic_vector(memory_reg);
    highest_time <= std_logic_vector(highest_time_reg);
    latest_time <= std_logic_vector(latest_time_reg);
    avg_time <= std_logic_vector(avg_time_reg);
    hours <= std_logic_vector(hours_reg);
    minutes <= std_logic_vector(minutes_reg);
    seconds <= std_logic_vector(seconds_reg);
end Behavioral;
